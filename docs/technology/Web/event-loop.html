<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件循环 - JS是怎么运行的？ | Lay</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="lay的博客">
    <link rel="preload" href="/blog/assets/css/0.styles.d6b61f4e.css" as="style"><link rel="preload" href="/blog/assets/js/app.dc2e23d2.js" as="script"><link rel="preload" href="/blog/assets/js/3.98e048c5.js" as="script"><link rel="preload" href="/blog/assets/js/5.34700501.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.9a4a5ef6.js"><link rel="prefetch" href="/blog/assets/js/11.e02e5f6f.js"><link rel="prefetch" href="/blog/assets/js/12.475a8e4d.js"><link rel="prefetch" href="/blog/assets/js/13.fc34cf78.js"><link rel="prefetch" href="/blog/assets/js/14.3ce29359.js"><link rel="prefetch" href="/blog/assets/js/15.38ffdbfa.js"><link rel="prefetch" href="/blog/assets/js/16.23c4bfb2.js"><link rel="prefetch" href="/blog/assets/js/17.6f7523a5.js"><link rel="prefetch" href="/blog/assets/js/18.16ac73ce.js"><link rel="prefetch" href="/blog/assets/js/19.5caafafd.js"><link rel="prefetch" href="/blog/assets/js/20.ff7dd27d.js"><link rel="prefetch" href="/blog/assets/js/21.51a4989c.js"><link rel="prefetch" href="/blog/assets/js/22.01b8729d.js"><link rel="prefetch" href="/blog/assets/js/23.229113c8.js"><link rel="prefetch" href="/blog/assets/js/24.e44b452c.js"><link rel="prefetch" href="/blog/assets/js/25.a8e0b34c.js"><link rel="prefetch" href="/blog/assets/js/4.c18a4a30.js"><link rel="prefetch" href="/blog/assets/js/6.256b6f79.js"><link rel="prefetch" href="/blog/assets/js/7.b04c5afc.js"><link rel="prefetch" href="/blog/assets/js/8.828d5f15.js"><link rel="prefetch" href="/blog/assets/js/9.25a8bbe6.js"><link rel="prefetch" href="/blog/assets/js/vendors~flowchart.1cd746f1.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.d6b61f4e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Lay</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/technology/Chrome/chrome-ext.html" class="nav-link">
  技术分享
</a></div><div class="nav-item"><a href="/blog/practice/Blog/vuepress.html" class="nav-link">
  实战分享
</a></div><div class="nav-item"><a href="/blog/notes/Typescript/TemplateLiteralTypes.html" class="nav-link">
  烂笔头
</a></div> <a href="https://github.com/lei4519/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/technology/Chrome/chrome-ext.html" class="nav-link">
  技术分享
</a></div><div class="nav-item"><a href="/blog/practice/Blog/vuepress.html" class="nav-link">
  实战分享
</a></div><div class="nav-item"><a href="/blog/notes/Typescript/TemplateLiteralTypes.html" class="nav-link">
  烂笔头
</a></div> <a href="https://github.com/lei4519/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Chrome</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Electron</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>MiniProgram</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Web</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/technology/Web/react-render.html" class="sidebar-link">React渲染流程</a></li><li><a href="/blog/technology/Web/rxjs-operate.html" class="sidebar-link">Rxjs 操作符快速入门</a></li><li><a href="/blog/technology/Web/lazy-img.html" class="sidebar-link">使用IntersectionObserver实现图片懒加载</a></li><li><a href="/blog/technology/Web/regexp.html" class="sidebar-link">正则</a></li><li><a href="/blog/technology/Web/adaptive-fontsize.html" class="sidebar-link">pc端 rem布局 非chrome浏览器字号小于12px的解决方案</a></li><li><a href="/blog/technology/Web/event-loop.html" aria-current="page" class="active sidebar-link">事件循环 - JS是怎么运行的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/technology/Web/event-loop.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Web/event-loop.html#浏览器进程与线程" class="sidebar-link">浏览器进程与线程</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Web/event-loop.html#微任务队列" class="sidebar-link">微任务队列</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Web/event-loop.html#vue-nexttick" class="sidebar-link">Vue.nextTick</a></li><li class="sidebar-sub-header"><a href="/blog/technology/Web/event-loop.html#问题答案" class="sidebar-link">问题答案</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="事件循环-js是怎么运行的？"><a href="#事件循环-js是怎么运行的？" class="header-anchor">#</a> 事件循环 - JS是怎么运行的？</h1> <ul><li>Vue.nextTick怎么实现的？为什么这个API可以保证回调函数在DOM更新后被调用？
<ul><li>抛开Vue，浏览器对DOM的更新是异步的吗？为什么Vue中的DOM更新是异步的？</li></ul></li> <li>如果setTimeout中注册回调函数，将时间设为0，当回调函数执行时DOM更新了吗？</li> <li>Vue.nextTick和setTimeout(callback, 0)，谁先执行？</li></ul> <p>如果上面这个问题你都知道了，那你对事件循环的理解在日常工作中就够用了，但还是建议看一下文章，因为会讲一些原理性的知识。</p> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <ul><li>JS引擎执行JS代码，是基于事件循环的。</li> <li>事件循环：单线程执行异步（非阻塞）代码的一种实现方式。</li> <li>JS执行线程为什么是单线程？
<ul><li>为了防止多个JS线程同时对DOM操作起冲突，比如一个更新了DOM属性，另一个删除了DOM。</li> <li>但这并不是最根本的原因，因为别的语言中也存在多个线程同时操作共享数据的情况，解决方案是加入线程锁，来避免多线程同时对相同的数据进行操作。JS之所以选用单线程，而不是多线程 + 线程锁呢？主要是在设计之初，就没想着做出一个完备强大的语言出来，布兰登·艾克用了10天的时间开发JS这门语言，所以肯定是怎么简单怎么来。（如果他知道20年后这门语言会成为世界上最热门的语言之一，不知道开发时会不会更严谨一点）</li></ul></li></ul> <h2 id="浏览器进程与线程"><a href="#浏览器进程与线程" class="header-anchor">#</a> 浏览器进程与线程</h2> <p>想把事件循环讲明白，就绕不过浏览器的进程和线程。</p> <blockquote><p>异步代码是什么？从哪里来的？</p></blockquote> <h3 id="chrome的多进程架构"><a href="#chrome的多进程架构" class="header-anchor">#</a> Chrome的多进程架构</h3> <p><img src="/blog/assets/img/IMG_9299.1f474ac4.jpg" alt="IMG_9301.jpeg"></p> <h4 id="browser进程"><a href="#browser进程" class="header-anchor">#</a> Browser进程</h4> <p>浏览器的主进程（负责协调、主控）</p> <ul><li>负责浏览器界面显示，与用户交互。如地址栏、书签栏、前进，后退等</li> <li>负责各个页面的管理，创建和销毁其他进程</li> <li>网络资源、本地存储、文件系统等</li></ul> <h4 id="插件进程"><a href="#插件进程" class="header-anchor">#</a> 插件进程</h4> <ul><li>每种类型的插件对应一个进程，仅当使用该插件时才创建</li></ul> <h4 id="gpu进程：用于3d绘制等"><a href="#gpu进程：用于3d绘制等" class="header-anchor">#</a> GPU进程：用于3D绘制等</h4> <h4 id="renderer-进程（浏览器内核）"><a href="#renderer-进程（浏览器内核）" class="header-anchor">#</a> Renderer 进程（浏览器内核）</h4> <ul><li>主要作用为页面渲染，脚本执行，事件处理等</li></ul> <h3 id="渲染进程（浏览器内核）中的线程"><a href="#渲染进程（浏览器内核）中的线程" class="header-anchor">#</a> 渲染进程（浏览器内核）中的线程</h3> <p><img src="/blog/assets/img/IMG_9302.da26b6b9.png" alt="IMG_9302.png"></p> <h4 id="gui渲染线程"><a href="#gui渲染线程" class="header-anchor">#</a> GUI渲染线程</h4> <blockquote><p>负责渲染工作</p></blockquote> <ul><li><p>渲染线程的工作流程
<img src="/blog/assets/img/IMG_9303.38f8af92.jpg" alt="IMG_9303.jpeg"></p></li> <li><p>GUI渲染线程与JS执行线程是互斥的，一个执行的时候另一个就会被挂起。</p></li> <li><p>常说的JS脚本加载和执行会阻塞DOM树的解析，指的就是互斥现象。</p> <ul><li><p>在JS执行过程中，对GUI线程的写操作，并不会被立即执行，而是被保存到一个队列中，等到JS引擎空闲时（当前宏任务执行完，下面会详细讲）被执行。</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'#000'</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'#001'</span>
</code></pre></div></li></ul></li></ul> <p>document.body.style.color = '#002'
```</p> <div class="language- extra-class"><pre><code>- 如果JS线程的当前宏任务执行时间过长，就会导致页面渲染不连贯，给用户的感觉就是页面卡顿。

- `1000毫秒 / 60帧 = 16.6毫秒`
</code></pre></div><h4 id="js引擎线程"><a href="#js引擎线程" class="header-anchor">#</a> JS引擎线程</h4> <blockquote><p>负责执行Javascript代码，V8引擎指的就是这个。</p></blockquote> <ul><li><p>JS引擎在执行代码时，会将需要执行的代码块当成一个个任务，放入任务队列中执行，JS引擎会不停的检查并运行任务队列中任务。</p> <div class="language-vue extra-class"><pre class="language-vue"><code>// html
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

// 将需要执行的代码包装成一个任务
const task = () =&gt; {
	console.log(1)
  console.log(2)
  console.log(3)
}

// 放入任务队列
pushTask(task)
</code></pre></div></li> <li><p>JS引擎执行逻辑：伪代码（所有的伪代码都是为了理解写的，并不是浏览器的真实实现）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 任务队列</span>
<span class="token keyword">const</span> queueTask <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// 将任务加入任务队列</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">pushTask</span> <span class="token operator">=</span> <span class="token parameter">task</span> <span class="token operator">=&gt;</span> queueTask<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 不停的去检查队列中是否有任务</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>queueTask<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 队列：先进先出</span>
    <span class="token keyword">const</span> task <span class="token operator">=</span> queueTask<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="事件触发线程"><a href="#事件触发线程" class="header-anchor">#</a> 事件触发线程</h4> <blockquote><p>事件监听触发</p></blockquote> <ul><li><p><code>document.body.addEventListener('click', () =&gt; {})</code></p></li> <li><p>伪代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// JS线程 -&gt; 监听事件</span>
<span class="token keyword">function</span> <span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token parameter">eventName<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">'eventTriggerThread'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> eventName<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 事件触发线程 -&gt; 监听元素对应事件</span>

<span class="token comment">// 事件触发线程 -&gt; 元素触发事件</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">pushTask</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="定时触发器线程"><a href="#定时触发器线程" class="header-anchor">#</a> 定时触发器线程:</h4> <blockquote><p>定时器setInterval与setTimeout所在线程</p></blockquote> <ul><li><p>伪代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// JS线程 -&gt; 开始计时</span>
<span class="token keyword">function</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> timeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">'timerThread'</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

  <span class="token comment">// 定时器线程 -&gt; 设定定时器开始计时</span>

<span class="token comment">// 定时器线程 -&gt; 计时器结束</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">pushTask</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="异步http请求线程"><a href="#异步http请求线程" class="header-anchor">#</a> 异步http请求线程</h4> <blockquote><p>Ajax、fetch请求</p></blockquote> <ul><li><p>伪代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// JS线程 -&gt; 开始请求</span>
XMLHttpRequest<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token string">'netWorkThread'</span><span class="token punctuation">,</span> options<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>

<span class="token comment">// 网络线程 -&gt; 开始请求</span>

<span class="token comment">// 网络线程 -&gt; 请求响应成功</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">pushTask</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="异步任务是什么？从哪来的？"><a href="#异步任务是什么？从哪来的？" class="header-anchor">#</a> 异步任务是什么？从哪来的？</h4> <ul><li>异步任务就是由浏览器其他线程处理并执行的任务。</li> <li>由JS引擎调用浏览器API来通知其他线程开始工作，并将执行成功的回调函数传入，当工作结束后其他线程会将回调函数推入任务队列中，由JS引擎执行回调函数。</li></ul> <h3 id="示例：任务队列的运行过程"><a href="#示例：任务队列的运行过程" class="header-anchor">#</a> 示例：任务队列的运行过程</h3> <ul><li>从输入URL到页面渲染都发生了什么？
<ul><li>只详细讲任务队列相关的流程</li></ul></li></ul> <ol><li><p>在地址栏输入URL，请求HTML，浏览器接受到响应结果，将HTML文本交给渲染线程，渲染线程开始解析HTML文本。</p> <div class="language-html extra-class"><pre class="language-html"><code>...
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'#f40'</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
    <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'/api/url'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li> <li><p>渲染线程解析过程中遇到<code>&lt;script&gt;</code>标签时，会把<code>&lt;script&gt;</code>中的代码包装成一个任务，放入JS引擎中的任务队列中，并挂起当前线程，开始运行JS线程。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">pushTask</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>JS线程检查到任务队列中有任务，就开始执行任务。</p> <ol><li>将对DOM的写操作放入队列中</li> <li>告诉事件触发线程，监听事件</li> <li>告诉定时器线程，开始计时</li> <li>告诉网络线程，开始请求</li></ol></li> <li><p>第一个宏任务执行完成，执行写操作队列（渲染页面）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>queueTask<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> task <span class="token operator">=</span> queueTask<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 执行写操作队列后进行渲染</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 检查空闲时间是否还够</span>
    <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>第一个任务就完全结束了，任务队列回到空的状态，第一个任务中注册了3个异步任务，但是这对JS引擎不会关心这些，它要做的就是接着不停的循环检查任务队列。</p></li> <li><p>为了简化流程，假设三个异步任务同时完成了，此时任务队列中就有了3个任务</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 任务队列</span>
<span class="token keyword">const</span> queueTask <span class="token operator">=</span> <span class="token punctuation">[</span>addEventListener<span class="token punctuation">,</span> setTimeout<span class="token punctuation">,</span> ajax<span class="token punctuation">]</span>
</code></pre></div></li> <li><p>但是不管有多少任务，都会按照上面的流程进行循环重复的执行，这整个流程被称为事件循环。</p></li></ol> <h2 id="微任务队列"><a href="#微任务队列" class="header-anchor">#</a> 微任务队列</h2> <p>上面说的是ES6之前的事件循环，只有一个任务队列，很好理解。</p> <p>在ES6标准中，ECMA要求JS引擎在事件循环中加入了一个新的队列：<strong>微任务队列</strong></p> <ul><li>为什么要加一个队列？要解决什么问题呢？</li></ul> <h4 id="宏任务队列的问题"><a href="#宏任务队列的问题" class="header-anchor">#</a> 宏任务队列的问题</h4> <p>实际功能：Vue为了性能优化，对响应式数据的修改并不会立即触发视图渲染，而是会放到一个队列中统一异步执行。（JS引擎对GUI线程写操作的思想）</p> <p>那怎么实现这个功能呢？想要异步执行，就需要创建一个异步任务，setTimeout是最合适的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 响应式数据修改</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>showModal <span class="token operator">=</span> <span class="token boolean">true</span>

<span class="token comment">// 记录需要重新渲染的视图</span>
<span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> flag <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment">// 触发setter</span>
<span class="token keyword">function</span> <span class="token function">setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 记录需要渲染的组件</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>render<span class="token punctuation">)</span>

 <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span>
flag <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 queue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">render</span> <span class="token operator">=&gt;</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 flag <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样实现有什么问题呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 任务队列</span>
<span class="token keyword">const</span> queueTask <span class="token operator">=</span> <span class="token punctuation">[</span>addEventListener<span class="token punctuation">,</span> setTimeout<span class="token punctuation">,</span> ajax<span class="token punctuation">]</span>
</code></pre></div><p>用上面的例子，现在任务队列里有三个任务，在第一个任务<code>addEventListener</code>中进行了Vue响应式修改。</p> <p>假设setTimeout立即就完成了，那么现在的任务队列如下:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 任务队列</span>
<span class="token keyword">const</span> queueTask <span class="token operator">=</span> <span class="token punctuation">[</span>addEventListener<span class="token punctuation">,</span> setTimeout<span class="token punctuation">,</span> ajax<span class="token punctuation">,</span> vueRender<span class="token punctuation">]</span>
</code></pre></div><p>这个结果符合任务队列的运行逻辑，但却不是我们想要的。</p> <p>因为视图更新的代码太靠后了，要知道每次任务执行之后并不是立即执行下一个任务，而是会执行<code>requestAnimationFrame</code>、渲染视图、检查剩余时间执行<code>requestIdleCallback</code>等等一系列的事情。</p> <p>按这个执行顺序，vueRender的代码会在页面渲染两次之后才执行。</p> <p>我们想要实现的效果是这个异步代码最好是在当前任务执行完就执行，理想的任务队列是下面这样。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 任务队列</span>
<span class="token keyword">const</span> queueTask <span class="token operator">=</span> <span class="token punctuation">[</span>addEventListener<span class="token punctuation">,</span> vueRender<span class="token punctuation">,</span> setTimeout<span class="token punctuation">,</span> ajax<span class="token punctuation">]</span>
</code></pre></div><p>相当于要给宏任务队列加入插入队列的功能，但是如果这么改，那就整个乱套了。之前的异步任务还有个先来后到的顺序，先加入先执行，这么一改，异步任务的顺序就完全无法控制了。</p> <p>上面的问题总结来说</p> <ol><li>现在的异步任务，执行颗粒度太大，两个任务间要做的事情太多，我们想要能够创建更快更高效的异步任务。</li> <li>现在的任务队列逻辑不能动。</li> <li>JS引擎本身没有创建异步任务的能力。
<ul><li>在这个例子中，需要执行的异步任务，跟别的线程是没有任何关系的，我们只是想通过异步任务来优化性能。</li></ul></li></ol> <h4 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h4> <p>既然之前的任务队列逻辑不能动，那不如就加个新队列：<strong>微任务队列</strong>。</p> <p>JS引擎自己创建的异步任务，就往这个微任务队列里放。通过别的线程创建的异步任务，还是按老样子放入之前的队列中（宏任务队列）。</p> <p>微任务队列，会在宏任务执行之后被清空执行。</p> <p>加入了微任务队列之后，JS引擎的代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 宏任务队列</span>
<span class="token keyword">const</span> macroTask <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// 微任务队列</span>
<span class="token keyword">const</span> microTask <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>macroTask<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> task <span class="token operator">=</span> macroTask<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">// 宏任务执行之后，清空微任务队列</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>microTask<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> micro <span class="token operator">=</span> microTask<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token function">micro</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意while循环的实现，只要微任务队列中有任务，就会一直执行直到队列为空。也就是说如果在微任务执行过程中又产生了微任务（向微任务队列中push了新值），这个新的微任务也会在这个while循环中被执行</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 微任务队列 = []</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  	Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 微任务队列 = [log1函数体]</span>

<span class="token comment">// log1函数体 = 微任务队列.shift()</span>
<span class="token comment">// 微任务队列 = []</span>

<span class="token comment">// log1函数体()</span>
<span class="token comment">// 微任务队列 = [log2函数体]</span>

<span class="token comment">// log2函数体 = 微任务队列.shift()</span>
<span class="token comment">// 微任务队列 = []</span>

<span class="token comment">// 渲染视图</span>
</code></pre></div><p>以上就是为什么要有微任务队列，以及微任务队列的运行逻辑。</p> <p>浏览器中可以产生微任务异步代码的API：<code>Promise.prototype.then</code>、<code>MutationObserver</code>、<code>setImmediate(IE、nodejs)</code>、<code>MessagePort.onmessage</code></p> <p>Vue渲染视图的异步代码就是放在微任务队列中的。</p> <blockquote><p>Vue2的nextTick实现为：Promise -&gt; setImmediate -&gt; MessagePort.onmessage -&gt; setTimeout</p></blockquote> <h2 id="vue-nexttick"><a href="#vue-nexttick" class="header-anchor">#</a> Vue.nextTick</h2> <blockquote><p>API介绍：使用nextTick注册的代码会在 DOM 更新之后被调用。</p></blockquote> <p>nextTick的实现比我们想的要简单的多，尤其是我们已经了解了微任务的执行逻辑。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 记录需要重新渲染的视图</span>
<span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> flag <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token comment">// 触发setter</span>
<span class="token keyword">function</span> <span class="token function">setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 记录需要渲染的组件</span>
  queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>render<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span>
  flag <span class="token operator">=</span> <span class="token boolean">true</span>
  <span class="token comment">// setTimeout 换成了 Promise, 将异步任务注册进微任务队列中</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    queue<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">render</span> <span class="token operator">=&gt;</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    flag <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 微任务队列：[]</span>

<span class="token keyword">this</span><span class="token punctuation">.</span>showModal <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token comment">// 微任务队列：[vueRender]</span>

<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 微任务队列：[vueRender, nextTickCallback]</span>
</code></pre></div><p>Vue3的nextTick（支持Proxy的浏览器不可能不支持Promise）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> resolvedPromise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> fn <span class="token operator">?</span> resolvedPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token operator">:</span> p
<span class="token punctuation">}</span>
</code></pre></div><h2 id="问题答案"><a href="#问题答案" class="header-anchor">#</a> 问题答案</h2> <ul><li>Vue.nextTick怎么实现的？为什么这个API可以保证回调函数在DOM更新后被调用？
<ul><li>DOM操作时同步的，nextTick注册的回调函数在vueRender函数之后，所以此时DOM已经更新了。</li></ul></li> <li>如果setTimeout中注册回调函数，将时间设为0，当回调函数执行时DOM更新了吗？
<ul><li>肯定更新了，setTimeout注册的是宏任务，宏任务执行时微任务肯定早就执行完了</li></ul></li> <li>Vue.nextTick和setTimeout(callback, 0)，谁先执行？
<ul><li>Vue.nextTick，这是个微任务。</li></ul></li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/lei4519/blog/edit/master/src/technology/Web/event-loop.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">7 个月前</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/technology/Web/adaptive-fontsize.html" class="prev">
        pc端 rem布局 非chrome浏览器字号小于12px的解决方案
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.dc2e23d2.js" defer></script><script src="/blog/assets/js/3.98e048c5.js" defer></script><script src="/blog/assets/js/5.34700501.js" defer></script>
  </body>
</html>
