"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[592],{6893:(e,t,a)=>{a.r(t),a.d(t,{default:()=>n});var r=a(6252);const h=(0,r.uE)('<h1 id="http-2" tabindex="-1"><a class="header-anchor" href="#http-2" aria-hidden="true">#</a> HTTP 2</h1><blockquote><p>http2.0是一种安全高效的下一代http传输协议。安全是因为http2.0建立在https协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。</p></blockquote><h2 id="http-1-x-问题" tabindex="-1"><a class="header-anchor" href="#http-1-x-问题" aria-hidden="true">#</a> HTTP 1.x 问题</h2><p>在http 1.0中，每此消息传输（请求/响应）都需要建立一次TCP链接。为了减少TCP链接的时间消耗，http 1.1中加入了 <code>connection: keep-alive</code>，来持久化TCP链接，进而使一个TCP链接可以重复使用。</p><p>但是TCP链接中的HTTP请求只能串行执行，一个TCP链接同一时间内只能处理一个HTTP请求。为了解决串行的阻塞问题，浏览器（chrome）会为同一个host建立多个（6个）TCP链接，如果6个TCP 链接依然不够用，那就要在不同的host中分布资源，以尽可能多的并行请求资源。</p><h2 id="http-2-优化内容" tabindex="-1"><a class="header-anchor" href="#http-2-优化内容" aria-hidden="true">#</a> HTTP 2 优化内容</h2><h3 id="二进制分帧-binary-format" tabindex="-1"><a class="header-anchor" href="#二进制分帧-binary-format" aria-hidden="true">#</a> 二进制分帧（Binary Format）</h3><p>突破http1.X标准的性能限制，改进传输性能，实现低延迟和高吞吐量</p><blockquote><p>帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。</p><p>消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。</p><p>流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。</p><p>流标识是描述二进制frame的格式，使得每个frame能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。</p></blockquote><h3 id="多路复用-multiplexing-连接共享" tabindex="-1"><a class="header-anchor" href="#多路复用-multiplexing-连接共享" aria-hidden="true">#</a> 多路复用 (Multiplexing) / 连接共享</h3><p>多路复用允许同时通过单一的http/2 连接发起多重的请求-响应消息。有了新的分帧机制后，http/2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。</p><p>http 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。http2连接可以承载数十或数百个流的复用，多路复用意味着来自很多流的数据包能够混合在一起通过同样连接传输。当到达终点时，再根据不同帧首部的流标识符重新连接将不同的数据流进行组装。</p><h3 id="头部压缩-header-compression" tabindex="-1"><a class="header-anchor" href="#头部压缩-header-compression" aria-hidden="true">#</a> 头部压缩（Header Compression）</h3><p>http/2使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，对于相同的数据，通信期间只需发送一次，如果首部发生了变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。</p><h4 id="压缩原理" tabindex="-1"><a class="header-anchor" href="#压缩原理" aria-hidden="true">#</a> 压缩原理</h4><p>用header字段表里的索引代替实际的header。</p><p>http/2的HPACK算法使用一份索引表来定义常用的http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。 例如 :method=GET 使用索引值 2 表示，:path=/index.html 使用索引值 5 表示</p><p>只要给服务端发送一个 Frame，该 Frame 的 Payload 部分存储 0x8285，Frame 的 Type 设置为 Header 类型，便可表示这个 Frame 属于 http Header，请求的内容是：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>GET /index.html\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>为什么是 0x8285，而不是 0x0205？这是因为高位设置为 1 表示这个字节是一个完全索引值（key 和 value 都在索引中）。</p><p>类似的，通过高位的标志位可以区分出这个字节是属于一个完全索引值，还是仅索引了 key，还是 key和value 都没有索引(参见：HTTP/2首部压缩的OkHttp3实现④)。</p><p>因为索引表的大小的是有限的，它仅保存了一些常用的 http Header，同时每次请求还可以在表的末尾动态追加新的 http Header 缓存，动态部分称之为 Dynamic Table。Static Table 和 Dynamic Table 在一起组合成了索引表</p><p>HPACK 不仅仅通过索引键值对来降低数据量，同时还会将字符串进行霍夫曼编码来压缩字符串大小。</p><p>以常用的 User-Agent 为例，它在静态表中的索引值是 58，它的值是不存在表中的，因为它的值是多变的。第一次请求的时候它的 key 用 58 表示，表示这是一个 User-Agent ，它的值部分会进行霍夫曼编码（如果编码后的字符串变更长了，则不采用霍夫曼编码）。</p><p>服务端收到请求后，会将这个 User-Agent 添加到 Dynamic Table 缓存起来，分配一个新的索引值。客户端下一次请求时，假设上次请求User-Agent的在表中的索引位置是 62， 此时只需要发送 0xBE（同样的，高位置 1），便可以代表：User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.146 Safari/537.36。</p><p>最终，相同的 Header 只需要发送索引值，新的 Header 会重新加入 Dynamic Table。</p><h3 id="请求优先级-request-priorities" tabindex="-1"><a class="header-anchor" href="#请求优先级-request-priorities" aria-hidden="true">#</a> 请求优先级（Request Priorities）</h3><p>通过流的形式进行数据传输时，每个流都可以携带31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。 服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），但这不是绝对的，也会根据实际的情况进行处理，否则又会出现阻塞的问题：高优先级请求慢阻塞低优先级资源。</p><ul><li>优先级最高：主要的html</li><li>优先级高：CSS文件</li><li>优先级中：js文件</li><li>优先级低：图片</li></ul><h3 id="服务端推送-server-push" tabindex="-1"><a class="header-anchor" href="#服务端推送-server-push" aria-hidden="true">#</a> 服务端推送（Server Push）</h3><p>服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',32),i={href:"https://mp.weixin.qq.com/s/L6GawHqcay-jhzZaPrSCKA",target:"_blank",rel:"noopener noreferrer"},l=(0,r.Uk)("深入理解http2.0协议，看这篇就够了！"),p={},n=(0,a(3744).Z)(p,[["render",function(e,t){const a=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.iD)(r.HY,null,[h,(0,r._)("p",null,[(0,r._)("a",i,[l,(0,r.Wm)(a)])])],64)}]])},3744:(e,t)=>{t.Z=(e,t)=>{const a=e.__vccOpts||e;for(const[e,r]of t)a[e]=r;return a}},8863:(e,t,a)=>{a.r(t),a.d(t,{data:()=>r});const r={key:"v-58f6250c",path:"/technology/HTTP/http2.html",title:"HTTP 2",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"HTTP 1.x 问题",slug:"http-1-x-问题",children:[]},{level:2,title:"HTTP 2 优化内容",slug:"http-2-优化内容",children:[{level:3,title:"二进制分帧（Binary Format）",slug:"二进制分帧-binary-format",children:[]},{level:3,title:"多路复用 (Multiplexing) / 连接共享",slug:"多路复用-multiplexing-连接共享",children:[]},{level:3,title:"头部压缩（Header Compression）",slug:"头部压缩-header-compression",children:[]},{level:3,title:"请求优先级（Request Priorities）",slug:"请求优先级-request-priorities",children:[]},{level:3,title:"服务端推送（Server Push）",slug:"服务端推送-server-push",children:[]}]},{level:2,title:"参考资料",slug:"参考资料",children:[]}],filePathRelative:"technology/HTTP/http2.md",git:{updatedTime:1616251303e3}}}}]);