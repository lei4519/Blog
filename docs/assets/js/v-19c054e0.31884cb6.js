"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[526],{6905:(n,s,e)=>{e.r(s),e.d(s,{default:()=>E});var a=e(6252);const t=(0,a.uE)('<h1 id="electron-进程通信" tabindex="-1"><a class="header-anchor" href="#electron-进程通信" aria-hidden="true">#</a> Electron 进程通信</h1><p>进程间的通信主要涉及一下四个模块</p><ol><li>ipcMain：在主进程中使用，用来接收和回复渲染进程的消息</li><li>ipcRenderer：在渲染进程中使用，用来接收和回复主进程、其他渲染进程的消息</li><li>webContents：每个渲染进程都拥有一个webContents对象，调用webContents.send可以向此进程发送消息</li><li>remote：能够在渲染进程中使用主进程模块</li></ol><blockquote><p>上面这些方法，其实都是node的事件机制，都是EventEmitter的实例。</p></blockquote><h2 id="主进程和渲染进程通信" tabindex="-1"><a class="header-anchor" href="#主进程和渲染进程通信" aria-hidden="true">#</a> 主进程和渲染进程通信</h2><h3 id="主进程-主动发送消息至-渲染进程" tabindex="-1"><a class="header-anchor" href="#主进程-主动发送消息至-渲染进程" aria-hidden="true">#</a> 主进程 主动发送消息至 渲染进程</h3>',6),p=(0,a.Uk)("使用 "),l={href:"https://www.electronjs.org/docs/api/web-contents#contentssendchannel-args",target:"_blank",rel:"noopener noreferrer"},c=(0,a.Uk)("webContents.send"),o=(0,a.uE)('<ul><li>主进程发送<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> BrowserWindow <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;electron&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> win <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BrowserWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nwin<span class="token punctuation">.</span>webContents<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&#39;eventType&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;message&#39;</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li>渲染进程接收<div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> ipcRenderer <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;electron&#39;</span><span class="token punctuation">)</span>\nipcRenderer<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;eventType&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">IpcRendererEvent<span class="token punctuation">,</span> msg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul><h3 id="渲染进程-主动发送消息至-主进程" tabindex="-1"><a class="header-anchor" href="#渲染进程-主动发送消息至-主进程" aria-hidden="true">#</a> 渲染进程 主动发送消息至 主进程</h3>',2),r=(0,a.Uk)("使用"),i={href:"https://www.electronjs.org/docs/api/ipc-renderer#ipcrenderersendchannel-args",target:"_blank",rel:"noopener noreferrer"},u=(0,a.Uk)("ipcRenderer.send"),d=(0,a.Uk)("发送异步消息"),k=(0,a.Uk)("使用"),h={href:"https://www.electronjs.org/docs/api/ipc-renderer#ipcrenderersendsyncchannel-args",target:"_blank",rel:"noopener noreferrer"},b=(0,a.Uk)("ipcRenderer.sendSync"),g=(0,a.Uk)("发送同步消息"),v=(0,a.uE)('<ul><li><p>渲染进程发送</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>ipcRenderer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&#39;eventType&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;msg&#39;</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li><li><p>主进程接收</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>ipcMain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;eventType&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">IpcMainEvent<span class="token punctuation">,</span> msg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><h3 id="回复消息的统一方式" tabindex="-1"><a class="header-anchor" href="#回复消息的统一方式" aria-hidden="true">#</a> 回复消息的统一方式</h3><p>上面两个例子的on方法，接受的回调函数都有一个event对象，可以使用这个event对象进行消息回复</p><p>先看一下这两个event对象有什么属性</p>',4),m={href:"https://www.electronjs.org/docs/api/structures/ipc-main-event",target:"_blank",rel:"noopener noreferrer"},w=(0,a.Uk)("IpcMainEvent"),f=(0,a._)("ul",null,[(0,a._)("li",null,"frameId: Integer -> 发送消息的渲染进程框架的ID（可能是iframe）"),(0,a._)("li",null,"sender: WebContents -> 发送消息的渲染进程的webContents引用，所以我们也可以使用sender.send来回复消息"),(0,a._)("li",null,"returnValue: any -> 同步回复消息（赋值）"),(0,a._)("li",null,"reply: Function -> 异步回复消息（函数调用）")],-1),_={href:"https://www.electronjs.org/docs/api/structures/ipc-renderer-event",target:"_blank",rel:"noopener noreferrer"},j=(0,a.Uk)("IpcRendererEvent"),I=(0,a._)("ul",null,[(0,a._)("li",null,"sender: IpcRenderer -> electron.IpcRender的引用"),(0,a._)("li",null,"senderId: Integer -> 发送消息的进程 webContents.id，渲染进程的消息触发可能是主进程，也可能是其他渲染进程，可以通过调用 event.sender.sendTo(event.senderId, msg)来回复此信息。从主进程直接发来的信息的 event.senderId是设置为0的。")],-1),y=(0,a.uE)('<h2 id="渲染进程之间通信" tabindex="-1"><a class="header-anchor" href="#渲染进程之间通信" aria-hidden="true">#</a> 渲染进程之间通信</h2><h3 id="通过全局属性-实现数据共享" tabindex="-1"><a class="header-anchor" href="#通过全局属性-实现数据共享" aria-hidden="true">#</a> 通过全局属性 实现数据共享</h3><ul><li><p>主进程中定义全局对象</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>global<span class="token punctuation">.</span>share <span class="token operator">=</span> <span class="token punctuation">{</span>\n  id<span class="token operator">:</span> <span class="token number">1</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>渲染进程中通过remote模块控制全局对象</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> share <span class="token operator">=</span> remote<span class="token punctuation">.</span><span class="token function">getGlobal</span><span class="token punctuation">(</span><span class="token string">&#39;share&#39;</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>share<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token comment">// get</span>\nshare<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// set</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul><blockquote><p>只能实现数据共享，并非真正的通信</p></blockquote><h3 id="利用主进程做消息中转" tabindex="-1"><a class="header-anchor" href="#利用主进程做消息中转" aria-hidden="true">#</a> 利用主进程做消息中转</h3><p>这个就不写代码了，就是<code>渲染进程A</code> 发送消息至 <code>主进程</code>, <code>主进程</code> 转发消息至 <code>渲染进程B</code>。</p><h3 id="通过进程id-直接获取目标进程-进行ipc通信" tabindex="-1"><a class="header-anchor" href="#通过进程id-直接获取目标进程-进行ipc通信" aria-hidden="true">#</a> 通过进程ID 直接获取目标进程 进行ipc通信</h3><ul><li><p>如何获取进程ID</p><ul><li>通过全局对象共享</li><li>主进程通过webContents.send发送消息</li></ul></li><li><p>通过ID发送消息</p><ul><li><code>ipcRender.sendTo(ID, eventType, msg)</code></li><li><code>remote.BrowserWindow.fromId(ID).webContents.send(eventType, msg)</code></li></ul></li></ul>',8),x={},E=(0,e(3744).Z)(x,[["render",function(n,s){const e=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[t,(0,a._)("p",null,[p,(0,a._)("a",l,[c,(0,a.Wm)(e)])]),o,(0,a._)("p",null,[r,(0,a._)("a",i,[u,(0,a.Wm)(e)]),d]),(0,a._)("p",null,[k,(0,a._)("a",h,[b,(0,a.Wm)(e)]),g]),v,(0,a._)("ul",null,[(0,a._)("li",null,[(0,a._)("p",null,[(0,a._)("a",m,[w,(0,a.Wm)(e)])]),f]),(0,a._)("li",null,[(0,a._)("p",null,[(0,a._)("a",_,[j,(0,a.Wm)(e)])]),I])]),y],64)}]])},3744:(n,s)=>{s.Z=(n,s)=>{const e=n.__vccOpts||n;for(const[n,a]of s)e[n]=a;return e}},8209:(n,s,e)=>{e.r(s),e.d(s,{data:()=>a});const a={key:"v-19c054e0",path:"/technology/Electron/ipc.html",title:"Electron 进程通信",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"主进程和渲染进程通信",slug:"主进程和渲染进程通信",children:[{level:3,title:"主进程 主动发送消息至 渲染进程",slug:"主进程-主动发送消息至-渲染进程",children:[]},{level:3,title:"渲染进程 主动发送消息至 主进程",slug:"渲染进程-主动发送消息至-主进程",children:[]},{level:3,title:"回复消息的统一方式",slug:"回复消息的统一方式",children:[]}]},{level:2,title:"渲染进程之间通信",slug:"渲染进程之间通信",children:[{level:3,title:"通过全局属性 实现数据共享",slug:"通过全局属性-实现数据共享",children:[]},{level:3,title:"利用主进程做消息中转",slug:"利用主进程做消息中转",children:[]},{level:3,title:"通过进程ID 直接获取目标进程 进行ipc通信",slug:"通过进程id-直接获取目标进程-进行ipc通信",children:[]}]}],filePathRelative:"technology/Electron/ipc.md",git:{updatedTime:1592231182e3}}}}]);